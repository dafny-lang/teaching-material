<!DOCTYPE html>
<html lang="en-US">
<head>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8" />
  <meta name="generator" content="Madoko, version 1.2.3" />
  <meta name="viewport" content="initial-scale=1.0" />
  <meta name="author" content="Jean-Baptiste Tristan \&amp, K. Rustan M. Leino" />
  <title>Verification of Object-Oriented Programs</title>
  <style type="text/css"  class="link">
  /*# sourceURL=madoko.css */
  
  .madoko .toc>.tocblock .tocblock .tocblock {
    margin-left: 2.25em;
  }
  .madoko .toc>.tocblock .tocblock {
    margin-left: 1.5em;
  }
  .madoko .toc-contents>.tocblock>.tocitem {
    font-weight: bold;
  }
  .madoko .toc {
    margin-top: 1em;
  }
  .madoko p.para-continue {
    margin-bottom: 0pt;
  }
  .madoko .para-block+p {
    margin-top: 0pt;
  }
  .madoko ul.para-block, .madoko ol.para-block {
    margin-top: 0pt;
    margin-bottom: 0pt;
  }
  .madoko ul.para-end, .madoko ol.para-end {
    margin-bottom: 1em;
  }
  .madoko dl {
    margin-left: 0em;
  }
  .madoko blockquote {
    font-style: italic;
  }
  .madoko a.localref {
    text-decoration: none;
  }
  .madoko a.localref:hover {
    text-decoration: underline;
  }
  .madoko .footnotes {
    font-size: smaller;
    margin-top: 2em;
  }
  .madoko .footnotes hr {
    width: 50%;
    text-align: left;
  }
  .madoko .footnote {
    margin-left: 1em;
  }
  .madoko .footnote-before {
    margin-left: -1em;
    width: 1em;
    display: inline-block;
  }
  .madoko .align-center, .madoko .align-center>p {
    text-align: center !important;
  }
  .madoko .align-center pre {
    text-align: left;
  }
  .madoko .align-center>* {
    margin-left: auto !important;
    margin-right: auto !important;
  }
  .madoko .align-left, .madoko .align-left>p {
    text-align: left !important;
  }
  .madoko .align-left>* {
    margin-left: 0pt !important;
    margin-right: auto !important;
  }
  .madoko .align-right, .madoko .align-right>p {
    text-align: right !important;
  }
  .madoko .align-right>* {
    margin-left: auto !important;
    margin-right: 0pt !important;
  }
  .madoko .align-center>table,
  .madoko .align-left>table,
  .madoko .align-right>table {
    text-align: left !important;
  }
  .madoko .equation-before {
    float: right;
  }
  .madoko .bibitem {
    font-size: smaller;
  }
  .madoko .bibsearch {
    font-size: x-small;
    text-decoration:none;
    color: black;
    font-family: "Segoe UI Symbol", Symbola, serif;
  }
  .madoko .block, .madoko .figure, .madoko .bibitem, .madoko .equation, .madoko div.math {
    margin-top: 1ex;
    margin-bottom: 1ex;
  }
  .madoko .figure {
    padding: 0.5em;
    margin-left: 0pt;
    margin-right: 0pt;
  }
  .madoko .hidden {
    display: none;
  }
  .madoko .invisible {
    visibility: hidden;
  }
  .madoko.preview .invisible {
    visibility: visible;
    opacity: 0.5;
  }
  .madoko code.code, .madoko span.code {
    white-space: pre-wrap;
  }
  .madoko hr, hr.madoko {
    border: none;
    border-bottom: black solid 1px;
    margin-bottom: 0.5ex;
  }
  .madoko .framed>*:first-child {
    margin-top: 0pt;
  }
  .madoko .framed>*:last-child {
    margin-bottom: 0pt;
  }
  .madoko ul.list-style-type-dash {
      list-style-type: none !important;
  }
  .madoko ul.list-style-type-dash > li:before {
      content: "\2013";
      position: absolute;
      margin-left: -1em;
  }
  .madoko table.madoko {
    border-collapse: collapse;
  }
  .madoko td, .madoko th {
    padding: 0ex 0.5ex;
    margin: 0pt;
    vertical-align: top;
  }
  .madoko .cell-border-left {
    border-left: 1px solid black;
  }
  .madoko .cell-border-right {
    border-right: 1px solid black;
  }
  .madoko thead>tr:first-child>.cell-line,
  .madoko tbody:first-child>tr:first-child>.cell-line {
    border-top: 1px solid black;
    border-bottom: none;
  }
  .madoko .cell-line, .madoko .cell-double-line {
    border-bottom: 1px solid black;
    border-top: none;
  }
  .madoko .cell-double-line {
    border-top: 1px solid black;
    padding-top: 1.5px !important;
  }
  .madoko .input-mathpre .MathJax_Display {
    text-align: left !important;
  }
  .madoko div.input-mathpre {
    text-align: left;
    margin-top: 1.5ex;
    margin-bottom: 1ex;
  }
  .madoko .math-rendering {
    text-align: left;
    white-space: pre;
    color: gray;
  }
  .madoko .mathdisplay {
    text-align: center;
  }
  .madoko span.math-rendering {
    display:inline-block;
    width:8em;
    overflow-x:auto;
    font-size:70%;
  }
  .madoko span.math-rendering::-webkit-scrollbar {
    width:4px;
  }
  .madoko .pretty table {
    border-collapse: collapse;
  }
  .madoko .pretty td {
    padding: 0em;
  }
  .madoko .pretty td.empty {
    min-width: 1.5ex;
  }
  .madoko .pretty td.expander {
    width: 100em;
  }
  body.madoko, .madoko .serif {
    font-family: Cambria,"Times New Roman","Liberation Serif","Times",serif;
  }
  .madoko .sans-serif {
    font-family: "Calibri", "Optima", sans-serif;
  }
  .madoko .symbol {
    font-family: "Segoe UI Symbol", Symbola, serif;
  }
  body.madoko {
    -webkit-text-size-adjust: 100%;       
    text-rendering: optimizeLegibility;
  }
  body.madoko {
    max-width: 88ex; 
    margin: 1em auto;
    padding: 0em 2em;
  }
  body.preview.madoko {
    padding: 0em 1em;
  }
  .madoko p {
    text-align: justify;
  }
  .madoko h1, .madoko h2, .madoko h3, .madoko h4 {
    margin-top: 1.22em;
    margin-bottom: 1ex;
  }
  .madoko h1+p, .madoko h2+p, .madoko h3+p, .madoko h4+p, .madoko h5+p  {
    margin-top: 1ex;
  }
  .madoko h5, .madoko h6 {
    margin-top: 1ex;
    font-size: 1em;
  }
  .madoko h5 {
    margin-bottom: 0.5ex;
  }
  .madoko h5 + p {
    margin-top: 0.5ex;
  }
  .madoko h6 {
    margin-bottom: 0pt;
  }
  .madoko h6 + p {
    margin-top: 0pt;
  }
  .madoko pre, .madoko code, .madoko kbd, .madoko samp, .madoko tt,
  .madoko .monospace, .madoko .token-indent, .madoko .reveal pre, .madoko .reveal code, .madoko .email {
    font-family: Consolas,"Andale Mono WT","Andale Mono",Lucida Console,Monaco,monospace,monospace;
    font-size: 0.85em;
  }
  .madoko pre code, .madoko .token-indent {
    font-size: 0.95em;
  }
  .madoko pre code {
    font-family: inherit !important;
  }
  .madoko ol.linenums li {
    background-color: white;
    list-style-type: decimal;
  }
  .madoko .remote {
    background-color: #F0FFF0;
  }
  .madoko .remote + * {
    margin-top: 0pt;
  }
  @media print {
    body.madoko {
      font-size: 10pt;
    }
    @page {
      margin: 1in 1.5in;
    }
  }
  @media only screen and (max-device-width:1024px) {
    body.madoko {
      padding: 0em 0.5em;
    }
    .madoko li {
      text-align: left;
    }
  }
  
    </style>
  <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/reveal.js/2.6.2/css/reveal.min.css"  class="link">
  <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/reveal.js/2.6.2/css/theme/solarized.css"  class="link">
  <script src="https://cdn.jsdelivr.net/reveal.js/2.6.2/lib/js/head.min.js"  class="script preview"></script>
  <script src="https://cdn.jsdelivr.net/reveal.js/2.6.2/js/reveal.js"  class="script preview"></script>
  <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {inlineMath: [['$','$']]},
       TeX: { 
         Macros: { mathid: ['\\mathit{#1\\hspace{0.1ex}}',1],
                   mathkw: ['\\mathsf{#1}',1],
                   mdmathindent: ['\\hspace{#1ex}',1],
                   mathpre: ['#1',1],
                 },
  
       }
    });
    MathJax.Hub.Register.StartupHook('TeX AMSmath Ready',function () { 
      MathJax.InputJax.TeX.Definitions.environment['mdmathpre'] = ['AMSarray',null,null,null,'l','0em','0em'];
    });
  </script>
  <script type="text/javascript" class="preview"
    src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
  </script>
  <meta name="apple-mobile-web-app-capable" content="yes" />
      <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
      <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
      <link rel="stylesheet" href="https://cdn.jsdelivr.net/reveal.js/2.6.2/css/theme/solarized.css" id="theme">    
      <!--[if lt IE 9]>
      <script src="https://cdn.jsdelivr.net/reveal.js/2.6.2/lib/js/html5shiv.js"></script>
      <![endif]-->
      <style>
      body.madoko {
        margin: 0pt;
        padding: 0pt;
        max-width: 100%;      
      }
      .madoko .reveal h1 {
          font-size: 3.7em;
      }
      .madoko .reveal h2 {
          font-size: 2.1em;
      }
      .reveal .authorblock .author {
          font-size: 120%;
          margin-bottom: 1ex;
      }        
      .reveal table {
          margin-left: auto;
          margin-right: auto;
      }
      .reveal pre table {
        margin-left: 0pt;
      }
      .madoko .reveal pre.pretty {
        padding-top: 0pt;
        padding-bottom: 0pt;
      }
      .reveal li p {
          text-align: left;
      }
      .reveal h2 {
          margin-bottom: 0.7em;
      }
      .reveal section ul,
      .reveal section ol {
          margin-top: 0.35em;
          margin-bottom: 0.35em;
      }
      .reveal section img.math-display {
          padding: 1em;
          box-shadow: none;
          border: none;
      }
      .reveal section img.math-inline {
          margin: 0pt;
          padding: 0pt;
          background-color: none;
          box-shadow: none;
          border: none;
      }
      .reveal section img {
          box-shadow: none;
          border: none;
      }
      .madoko .reveal pre {
          border: 1px solid black;
          word-wrap: normal;
          background-color: white;
          font-size: 0.7em;
          padding: 0.7em;
          line-height: 100%;
          width: 100%;
      }      
      .reveal pre code, .reveal code {
          padding: 0pt;
      }
      .reveal nav.toc {
          line-height: 1em;
          font-size: 60%;
          overflow-y: auto;
      }    
      .reveal .tocitem {
          text-align: left;
      }
      .reveal .toc>.tocblock .tocblock {
          margin-left: 0.5em;
      }   
      .reveal .toc>.tocblock .tocblock .tocblock {
          margin-left: 1em;
      }
      .reveal .bibliography {
        height: 18em;
        overflow-y: auto;
        font-size: 0.8em;
        line-height: 1.25;
      }
      .reveal section[data-smaller=""],
      .reveal section[data-smaller="true"] {
        font-size: 80%;
        width: 110%;
      }
      .reveal .slides>section[data-smaller=""],
      .reveal .slides>section[data-smaller="true"] {
        left: -55%;
      }
      .reveal .details {
        display: none;
      }
      .reveal[data-details=""] .details,
      .reveal[data-details="true"] .details {
        display: initial;
      }
      /* Display in the preview window */
      html, body.madoko.preview, body.madoko.preview-full, .body.madoko {
        height  : 100% !important;
        width   : auto!important;
        padding : 0pt !important;
        margin  : 0pt !important;
      }
      body.madoko.preview, body.madoko.preview-full, .preview .body.madoko {
        overflow: hidden !important;
      }
      body.preview .reveal .slides .fragment {
        visibility: visible;
        opacity: 0.5;
      }
      body.preview .reveal .slides .fragment.visible {
        opacity: 1.0;
      }
      .preview .reveal div.notes,
      .preview .reveal aside.notes {
        display  : block;
        position : absolute;
        width    : 30%;
        left     : 70%;
        top      : -15%;
        font-size: 50%;
        border   : 1px solid black;
        border-radius   : 10px;
        background-color: white;
      }
      /* 'static' display in the preview window, unused for now */
      body.preview.static div.reveal, 
      body.preview.static div.ticreveal .slides, 
      body.preview.static div.reveal section {
        display: block !important;
        position: relative !important;
        width: auto !important;      
      }
      body.preview.static div.reveal section {
        border: solid 1px black;
        padding: 1em !important;
        margin-top: 1em;
        min-height: 15em;
        top: 0pt;
      }
      body.madoko.preview.static section {
        font-size: 75%;
      }
      body.madoko.preview.static {
        padding: 0em 1em !important;
      }
      body.madoko.preview.static .reveal pre {
        width: 95%;
      }    
      body.preview .reveal[data-details="false"] .details {
        display: initial;
        color: gray;
      }
      body.preview .reveal[data-long="false"] section[data-long] {
        border-left: 2px black solid;
      }
      </style>
      <script>    
      // Full list of configuration options available here:
      // https://github.com/hakimel/reveal.js#configuration
      window.revealConfig = {
          controls: true,
          progress: true,
          history: true,
          center: /^\s*(true|1)\s*$/i.test("true"),
          slideNumber: /^\s*(true|1)\s*$/i.test("true"),
          dependencies: [
            { src: 'https://cdn.jsdelivr.net/reveal.js/2.6.2/lib/js/classList.js', condition: function() { return !document.body.classList; } },
            { src: 'https://cdn.jsdelivr.net/reveal.js/2.6.2/plugin/zoom-js/zoom.js', async: true, condition: function() { return !!document.body.classList; } },
            { src: 'https://cdn.jsdelivr.net/reveal.js/2.6.2/plugin/notes/notes.js', async: true, condition: function() { return !!document.body.classList; } },
          ],
      };
      function revealAddFragments() {
        [].forEach.call(document.querySelectorAll( ".fragmented" ), function(elem0) {
          var elem = (/^H\d$/.test(elem0.nodeName) ? elem0.parentNode : elem0);
          [].forEach.call(elem.children, function(item) {
            if (item==elem0) return;
            if (item && !/\bfragment(ed)?\b/.test(item.className) && item.nodeType===1) {
              item.className = item.className + " fragment";
            }
          });
        });
      }
      function revealQuotedList(listType) {
        //compatibility with Rmarkdown slides
        [].forEach.call( document.querySelectorAll("blockquote>" + listType), function(ul) {
          if (!/\bfragmented\b/.test(ul.className)) {
            ul.className = ul.className + " fragmented";
          }        
          var quote = ul.parentNode;
          if (quote.childElementCount===1) {
            quote.parentNode.replaceChild(ul,quote);
          }
        });
      }
      function revealBuildToFragmented() {
        [].forEach.call(document.querySelectorAll( ".build" ), function(elem) {
          if (elem && !/\bfragmented\b/.test(elem.className) && elem.nodeType===1) {
            elem.className = elem.className + " fragmented";
          }
        });
      }
      function revealDivNotesToAside() {
        [].forEach.call(document.querySelectorAll("div.notes"), function(elem) {
          var aside = document.createElement("ASIDE");
          if (elem.id) aside.id = elem.id;
          aside.className = elem.className;
          [].forEach.call(elem.attributes, function(attr) {
            aside.setAttribute( attr.name, attr.value );
          });
          aside.innerHTML = elem.innerHTML;
          elem.parentNode.replaceChild(aside,elem);
        });
      }
      function revealDataQuery() {
        var reveal = document.querySelector(".reveal");
        if (!reveal) return;
        window.location.search.replace(/\bdata-(\w+)(?:=(\w+))?\b/g, function(matched,key,value) {
          reveal.setAttribute("data-" + key, (value ? value : ""));
          return matched;
        });
      }
      function revealRemoveLong() {
        // remove parts for 'long' presentation
        if (/\bpreview(?![\w\-])/.test(document.body.className)) return;
        var reveal = document.querySelector(".reveal");
        if (!reveal) return;
        var value = reveal.hasAttribute("data-long") ? reveal.getAttribute("data-long") : null;
        if (value==null || value=="false" || value=="0") {
          [].forEach.call( document.querySelectorAll("section[data-long]"), function(elem) {
            elem.parentNode.removeChild(elem);
          });
        }
      }
      revealConfig.onLoad = function() {
        revealConfig.getEmbeddedImages();
        revealDataQuery();
        revealRemoveLong();
        revealQuotedList("ul");
        revealQuotedList("ol");
        revealBuildToFragmented();
        revealDivNotesToAside();
        revealAddFragments();
      };
      document.addEventListener("load",revealConfig.onLoad);    
      document.addEventListener("DOMContentLoaded", function() {
        if (typeof Reveal !== "undefined" && !Reveal.isReady()) {
          revealConfig.onLoad();
          Reveal.initialize(revealConfig);
        }
      });    
      // add support for printing:
      // use  ?print-pdf to get a pdf-printable version (in Chrome)
      // use  ?print-paper to get a paper-printable version.
      revealConfig.initPrint = function() {
        var cssLink = null;
        var bodyClass = null;
        var cap = window.location.search.match(/\bprint-(\w+)\b/);
        if (cap) {
          bodyClass = cap[0];
          cssLink = "https://cdn.jsdelivr.net/reveal.js/2.6.2/css/print/" + cap[1] + ".css";
        }
        if (cssLink) {
          var link  = document.createElement( "link" );
          link.rel  = "stylesheet";
          link.type = "text/css";
          link.href = cssLink;
          var head = document.getElementsByTagName( 'head' )[0];
          if (head) head.appendChild( link );
        }
        if (bodyClass) {
          document.body.className = document.body.className + " " + bodyClass;
        }
      };
      revealConfig.getEmbeddedImages = function() {
        var images = {};
        [].forEach.call( document.querySelectorAll("img[data-linkid]"), function(img) {
          var linkid = img.getAttribute("data-linkid");
          if (linkid) images["/" + linkid] = img.src;
          var path = img.getAttribute("data-path");
          if (path) images["/" + path] = img.src;
        });     
        [].forEach.call( document.querySelectorAll("section"), function(slide) {
          var attrName = "data-background";
          var image = slide.getAttribute(attrName);
          if (!image) {
            attrName = "data-background-image";
            image = slide.getAttribute(attrName);
          }
          if (!image) return;
          var cap = /^\s*!?\[([^\]]+)\]\s*$/.exec(image);
          var href = images["/" + (cap ? cap[1] : image)];
          if (!href) return;
          if (attrName==="data-background" && /^data:/.test(href)) href = "url(" + href + ")";
          slide.setAttribute(attrName, href);
        });
      };    
      </script>
  </head>
<body class="madoko">

<div class="body madoko" style="line-adjust:0">
<div class="reveal" data-long="false" data-details="false" data-line="36" style="line-adjust:0">
<div class="slides" data-line="36" style="line-adjust:0">

<section class="titleblock align-center para-block" data-line="37" style="text-align:center;line-adjust:0">
<div class="titleheader align-center" data-line="37" style="text-align:center;line-adjust:0">
<h1 class="title para-block" data-line="37" style="font-weight:bold;margin-bottom:0.5ex;font-size:3em;line-adjust:0"><span data-line="37"></span>Verification of Object-Oriented Programs</h1></div>
<div class="authors align-center" data-line="42" style="text-align:center;width:80%;line-adjust:0"><table class="authorrow columns block" data-line="42" style="margin-top:2ex;width:100%;line-adjust:0">
<tbody><tr><td class="author column" data-line="42" style="text-align:center;font-size:x-large;line-adjust:0">
<div class="authorname" data-line="42" style="font-size:1.4em;line-adjust:0"><span data-line="42"></span>Jean-Baptiste Tristan & K. Rustan M. Leino</div></td></tr></tbody></table></div></section><!-- This file was automatically generated from MutableStaticDataStructures.mdk -->




<section id="sec-recap" class="section section1" data-section-depth="1" data-line="44"><h2 id="heading-sec-recap" class="h1" data-heading-depth="1" style="display:block">Recap</h2>
<ul class="ul list-dash compact" data-line="46">
<li class="li ul-li list-dash-li compact-li" data-line="46"><span data-line="46"></span>We have seen how to reason about

<ul class="ul list-dash compact" data-line="47">
<li class="li ul-li list-dash-li compact-li" data-line="47"><span data-line="47"></span>Functional programs
</li>
<li class="li ul-li list-dash-li compact-li" data-line="48"><span data-line="48"></span>Imperative code without and with pointers
</li></ul></li>
<li class="li ul-li list-dash-li compact-li" data-line="49"><span data-line="49"></span>Now we are going to <span data-line="49"></span>&#8220;verify&#8221;<span data-line="49"></span> objects
</li></ul>
</section>
<section id="sec-objects-and-verification" class="section section1" data-section-depth="1" data-line="51"><h2 id="heading-sec-objects-and-verification" class="h1" data-heading-depth="1" style="display:block">Objects and verification</h2>
<ul class="ul list-dash loose" data-line="53">
<li class="li ul-li list-dash-li loose-li" data-line="53">
<p data-line="53"><span data-line="53"></span>Verifying objects is different from code
</p></li>
<li class="li ul-li list-dash-li loose-li" data-line="54">
<p data-line="54"><span data-line="54"></span>So far, an invariant was always attached to a single function of statement
</p></li>
<li class="li ul-li list-dash-li loose-li" data-line="55">
<p data-line="55"><span data-line="55"></span>In an object, the invariant is shared by all methods in the class
</p></li>
<li class="li ul-li list-dash-li loose-li" data-line="56">
<p data-line="56"><span data-line="56"></span>The invariant might need to be framed using <span data-line="56"></span><code class="code code1">this</code><span data-line="56"></span>
</p><!-- inline-dafny MutableStaticDataStructures/A3 -->


<pre class="para-block pre-fenced pre-fenced3 language-dafnyx lang-dafnyx dafnyx colorized" data-line="59" data-line-first="60" style="display:block"><code data-line="60">  <span style="color:blue">class</span> B {

    <span style="color:blue">var</span> x: <span style="color:teal">nat</span>

    <span style="color:blue">predicate</span> Invariant()
      <span style="color:purple">reads</span> <span style="color:blue">this</span>
    {
      x % <span class="constant" style="color:purple">2</span> == <span class="constant" style="color:purple">0</span>
    }

  }</code></pre></li></ul>
</section>
<section id="sec-objects-and-verification----1" class="section section1" data-section-depth="1" data-line="73"><h2 id="heading-sec-objects-and-verification----1" class="h1" data-heading-depth="1" style="display:block">Objects and verification &#8211; 1</h2>
<ul class="ul list-dash loose" data-line="75">
<li class="li ul-li list-dash-li loose-li" data-line="75">
<p data-line="75"><span data-line="75"></span>constructor
</p><!-- inline-dafny MutableStaticDataStructures/A4 -->


<pre class="para-block pre-fenced pre-fenced3 language-dafnyx lang-dafnyx dafnyx colorized" data-line="78" data-line-first="79" style="display:block"><code data-line="79">  <span style="color:blue">class</span> B {

    <span style="color:darkgreen">// ...</span>

    <span style="color:blue">constructor</span>(x: <span style="color:teal">nat</span>)
      <span style="color:purple">requires</span> x % <span class="constant" style="color:purple">2</span> == <span class="constant" style="color:purple">0</span>
      <span style="color:purple">ensures</span> Invariant()
    {
      <span style="color:blue">this</span>.x := x;
    }

  }</code></pre></li></ul>
</section>
<section id="sec-objects-and-verification----2" class="section section1" data-section-depth="1" data-line="93"><h2 id="heading-sec-objects-and-verification----2" class="h1" data-heading-depth="1" style="display:block">Objects and verification &#8211; 2</h2>
<ul class="ul list-dash loose" data-line="95">
<li class="li ul-li list-dash-li loose-li" data-line="95">
<p data-line="95"><span data-line="95"></span>Methods might also need to be framed
</p></li>
<li class="li ul-li list-dash-li loose-li" data-line="96">
<p data-line="96"><span data-line="96"></span>Methods/functions that read the object usually requires the invariant as a precondition
</p></li>
<li class="li ul-li list-dash-li loose-li" data-line="97">
<p data-line="97"><span data-line="97"></span>Methods/functions that modify the object must ensure the invariant as a postcondition
</p><!-- inline-dafny MutableStaticDataStructures/A5 -->


<pre class="para-block pre-fenced pre-fenced3 language-dafnyx lang-dafnyx dafnyx colorized" data-line="100" data-line-first="101" style="display:block"><code data-line="101">  <span style="color:blue">class</span> B {

    <span style="color:darkgreen">// ...</span>

    <span style="color:blue">method</span> Add(y: <span style="color:teal">nat</span>)
      <span style="color:purple">requires</span> Invariant()
      <span style="color:purple">modifies</span> <span style="color:blue">this</span>
      <span style="color:purple">ensures</span> Invariant()
    {
      <span style="color:blue">this</span>.x := <span style="color:blue">this</span>.x + <span class="constant" style="color:purple">2</span> * y;
    }
  }</code></pre></li></ul>
</section>
<section id="sec-objects-and-verification----3" class="section section1" data-section-depth="1" data-line="115"><h2 id="heading-sec-objects-and-verification----3" class="h1" data-heading-depth="1" style="display:block">Objects and verification &#8211; 3</h2>
<ul class="ul list-dash loose" data-line="117">
<li class="li ul-li list-dash-li loose-li" data-line="117">
<p data-line="117"><span data-line="117"></span>Some functions/methods read from the object
</p></li>
<li class="li ul-li list-dash-li loose-li" data-line="118">
<p data-line="118"><span data-line="118"></span>Typically, they ensures some postcondition
</p></li>
<li class="li ul-li list-dash-li loose-li" data-line="119">
<p data-line="119"><span data-line="119"></span>The invariant must be strong enough for the postcondition to hold
</p><!-- inline-dafny MutableStaticDataStructures/A6 -->


<pre class="para-block pre-fenced pre-fenced3 language-dafnyx lang-dafnyx dafnyx colorized" data-line="122" data-line-first="123" style="display:block"><code data-line="123">  <span style="color:blue">class</span> B {

    <span style="color:darkgreen">// ...</span>

    <span style="color:blue">function</span> Get(): <span style="color:teal">nat</span>
      <span style="color:purple">requires</span> Invariant()
      <span style="color:purple">reads</span> <span style="color:blue">this</span>
      <span style="color:purple">ensures</span> Get() % <span class="constant" style="color:purple">2</span> == <span class="constant" style="color:purple">0</span>
    {
      x
    }

  }</code></pre></li></ul>
</section>
<section id="sec-objects-and-verification----4" class="section section1" data-section-depth="1" data-line="138"><h2 id="heading-sec-objects-and-verification----4" class="h1" data-heading-depth="1" style="display:block">Objects and verification &#8211; 4</h2>
<ul class="ul list-dash compact" data-line="140">
<li class="li ul-li list-dash-li compact-li" data-line="140"><span data-line="140"></span>Why is it difficult?
</li>
<li class="li ul-li list-dash-li compact-li" data-line="141"><span data-line="141"></span>Once you understand the need for an object invariant predicate, what is the big deal?
</li>
<li class="li ul-li list-dash-li compact-li" data-line="142"><span data-line="142"></span>It is hard to get it all correct at once
</li>
<li class="li ul-li list-dash-li compact-li" data-line="143"><span data-line="143"></span>You need a strategy to co-evolve the code and the invariant and the functional specification
</li></ul>
</section>
<section id="sec-objects-and-verification----5" class="section section1" data-section-depth="1" data-line="146"><h2 id="heading-sec-objects-and-verification----5" class="h1" data-heading-depth="1" style="display:block">Objects and verification &#8211; 5</h2>
<ul class="ul list-dash loose" data-line="148">
<li class="li ul-li list-dash-li loose-li" data-line="148">
<p data-line="148"><span data-line="148"></span>Note that so far it would be fine for <span data-line="148"></span><code class="code code1">Add</code><span data-line="148"></span> not to ensure the invariant
</p></li>
<li class="li ul-li list-dash-li loose-li" data-line="149">
<p data-line="149"><span data-line="149"></span>What would go wrong?
</p></li>
<li class="li ul-li list-dash-li loose-li" data-line="150">
<p data-line="150"><span data-line="150"></span>Function precondition might not hold when you use the object
</p><!-- inline-dafny MutableStaticDataStructures/A7 -->


<pre class="para-block pre-fenced pre-fenced3 language-dafnyx lang-dafnyx dafnyx colorized" data-line="153" data-line-first="154" style="display:block"><code data-line="154">  <span style="color:blue">class</span> B {

    <span style="color:darkgreen">// ..., but without postcondition of Add</span>

  }

  <span style="color:blue">method</span> Client() {
    <span style="color:blue">var</span> b: B := <span style="color:blue">new</span> B(<span class="constant" style="color:purple">2</span>);
    b.Add(<span class="constant" style="color:purple">3</span>);
    <span style="color:blue">var</span> c: <span style="color:teal">nat</span> := b.Get(); <span style="color:darkgreen">// Error</span>
  }</code></pre></li></ul>
</section>
<section id="sec-objects-and-verification----6" class="section section1" data-section-depth="1" data-line="167"><h2 id="heading-sec-objects-and-verification----6" class="h1" data-heading-depth="1" style="display:block">Objects and verification &#8211; 6</h2>
<ul class="ul list-dash loose" data-line="169">
<li class="li ul-li list-dash-li loose-li" data-line="169">
<p data-line="169"><span data-line="169"></span>As long as an object doesn<span data-line="169"></span>&#39;<span data-line="169"></span>t change what other objects in contains, the framing is static and simple
</p></li>
<li class="li ul-li list-dash-li loose-li" data-line="170">
<p data-line="170"><span data-line="170"></span>If an object uses another object, you must have some way to refer to its frame
</p></li>
<li class="li ul-li list-dash-li loose-li" data-line="171">
<p data-line="171"><span data-line="171"></span>Objects can define a ghost constant, usually called <span data-line="171"></span><code class="code code1">Repr</code><span data-line="171"></span> (for <span data-line="171"></span><em class="em-low1">representation</em><span data-line="171"></span>),
to denote the set of contained objects
</p><!-- inline-dafny MutableStaticDataStructures/A8 -->


<pre class="para-block pre-fenced pre-fenced3 language-dafnyx lang-dafnyx dafnyx colorized" data-line="175" data-line-first="176" style="display:block"><code data-line="176">  <span style="color:blue">class</span> D {
    <span style="color:blue">var</span> x: <span style="color:teal">nat</span>
    <span style="color:blue">ghost</span> <span style="color:blue">const</span> Repr: <span style="color:teal">set</span>&lt;<span style="color:teal">object</span>&gt; := {<span style="color:blue">this</span>}
  }

  <span style="color:blue">class</span> E {
    <span style="color:blue">method</span> M(a: D)
      <span style="color:purple">modifies</span> a.Repr
    {
      a.x := <span class="constant" style="color:purple">4</span>;
    }
  }</code></pre></li></ul>
</section>
<section id="sec-ghost-state----10" class="section section1" data-section-depth="1" data-line="190"><h2 id="heading-sec-ghost-state----10" class="h1" data-heading-depth="1" style="display:block">Ghost state &#8211; 10</h2>
<ul class="ul list-dash loose" data-line="192">
<li class="li ul-li list-dash-li loose-li" data-line="192">
<p data-line="192"><span data-line="192"></span>Here again, ghost state is <span data-line="192"></span><strong class="strong-star2">very</strong><span data-line="192"></span> useful
</p></li>
<li class="li ul-li list-dash-li loose-li" data-line="193">
<p data-line="193"><span data-line="193"></span>It can be used to relate the object to a purely functional implementation
</p></li>
<li class="li ul-li list-dash-li loose-li" data-line="194">
<p data-line="194"><span data-line="194"></span>It can be used to carry information about the past of the object
</p></li>
<li class="li ul-li list-dash-li loose-li" data-line="195">
<p data-line="195"><span data-line="195"></span>For example, to keep track of accesses to a storage
</p><!-- inline-dafny MutableStaticDataStructures/A9 -->


<pre class="para-block pre-fenced pre-fenced3 language-dafnyx lang-dafnyx dafnyx colorized" data-line="198" data-line-first="199" style="display:block"><code data-line="199">  <span style="color:blue">datatype</span> Entry&lt;T&gt; = Entry(key: <span style="color:teal">nat</span>, value: T)

  <span style="color:blue">class</span> Storage&lt;T&gt; {
    <span style="color:blue">ghost</span> <span style="color:blue">var</span> log: <span style="color:teal">seq</span>&lt;Entry&lt;T&gt;&gt;
  }</code></pre></li></ul>
</section>
<section id="sec-dynamic-data-structures" class="section section1" data-section-depth="1" data-line="206"><h2 id="heading-sec-dynamic-data-structures" class="h1" data-heading-depth="1" style="display:block">Dynamic data structures</h2>
<ul class="ul list-dash compact" data-line="208">
<li class="li ul-li list-dash-li compact-li" data-line="208"><span data-line="208"></span>Some data structures are aggregations of objects
</li>
<li class="li ul-li list-dash-li compact-li" data-line="209"><span data-line="209"></span>Example: linked list
</li>
<li class="li ul-li list-dash-li compact-li" data-line="210"><span data-line="210"></span>LRU cache, but only indirectly
</li>
<li class="li ul-li list-dash-li compact-li" data-line="211"><span data-line="211"></span>In such a case, the frame is dynamic
</li>
<li class="li ul-li list-dash-li compact-li" data-line="212"><span data-line="212"></span>We<span data-line="212"></span>&#39;<span data-line="212"></span>re going to discuss verification of such aggregates
</li></ul>
</section>
<section id="sec-linked-lists" class="section section1" data-section-depth="1" data-line="215"><h2 id="heading-sec-linked-lists" class="h1" data-heading-depth="1" style="display:block">Linked lists</h2>
<ul class="ul list-dash compact" data-line="217">
<li class="li ul-li list-dash-li compact-li" data-line="217"><span data-line="217"></span>We are going to consider two ways to implement a linked list
</li>
<li class="li ul-li list-dash-li compact-li" data-line="218"><span data-line="218"></span>In both implementations, the data is contained in cells
</li>
<li class="li ul-li list-dash-li compact-li" data-line="219"><span data-line="219"></span>In the first, the linked list is defined as the cell
</li>
<li class="li ul-li list-dash-li compact-li" data-line="220"><span data-line="220"></span>In the second, the linked list has a special root object
</li></ul>
</section>
<section id="sec-linked-list-example----1" class="section section1" data-section-depth="1" data-line="222"><h2 id="heading-sec-linked-list-example----1" class="h1" data-heading-depth="1" style="display:block">Linked list example &#8211; 1</h2>
<ul class="ul list-dash loose" data-line="224">
<li class="li ul-li list-dash-li loose-li" data-line="224">
<p data-line="224"><span data-line="224"></span>Let<span data-line="224"></span>&#39;<span data-line="224"></span>s grow the API, strengthening the invariant as we go
</p><!-- inline-dafny MutableDynamicDataStructures/A2 -->


<pre class="para-block pre-fenced pre-fenced3 language-dafnyx lang-dafnyx dafnyx colorized" data-line="227" data-line-first="228" style="display:block"><code data-line="228">  <span style="color:blue">class</span> LL&lt;T&gt; {

    <span style="color:blue">const</span> value: T
    <span style="color:blue">var</span> next: LL?&lt;T&gt;

    <span style="color:blue">constructor</span>(value: T)
      <span style="color:purple">ensures</span> <span style="color:blue">this</span>.value == value
      <span style="color:purple">ensures</span> <span style="color:blue">this</span>.next == <span style="color:blue">null</span>
    {
      <span style="color:blue">this</span>.value := value;
      next := <span style="color:blue">null</span>;
    }
  }</code></pre></li></ul>
</section>
<section id="sec-linked-list-example----2" class="section section1" data-section-depth="1" data-line="243"><h2 id="heading-sec-linked-list-example----2" class="h1" data-heading-depth="1" style="display:block">Linked list example &#8211; 2</h2>
<ul class="ul list-dash loose" data-line="245">
<li class="li ul-li list-dash-li loose-li" data-line="245">
<p data-line="245"><span data-line="245"></span><code class="code code1">Cons</code><span data-line="245"></span> creates a new cell and attaches to its tail
</p><!-- inline-dafny MutableDynamicDataStructures/A3 -->


<pre class="para-block pre-fenced pre-fenced3 language-dafnyx lang-dafnyx dafnyx colorized" data-line="248" data-line-first="249" style="display:block"><code data-line="249">  <span style="color:blue">class</span> LL&lt;T&gt; ... {

    <span style="color:blue">method</span> Cons(v: T) <span style="color:blue">returns</span> (l: LL&lt;T&gt;) {
      l := <span style="color:blue">new</span> LL(v);
      l.next := <span style="color:blue">this</span>;
    }

  }</code></pre></li></ul>
</section>
<section id="sec-linked-list-example----3" class="section section1" data-section-depth="1" data-line="259"><h2 id="heading-sec-linked-list-example----3" class="h1" data-heading-depth="1" style="display:block">Linked list example &#8211; 3</h2>
<ul class="ul list-dash loose" data-line="261">
<li class="li ul-li list-dash-li loose-li" data-line="261">
<p data-line="261"><span data-line="261"></span><code class="code code1">Head</code><span data-line="261"></span> and <span data-line="261"></span><code class="code code1">Tail</code><span data-line="261"></span> can be defined as functions
</p><!-- inline-dafny MutableDynamicDataStructures/A4 -->


<pre class="para-block pre-fenced pre-fenced3 language-dafnyx lang-dafnyx dafnyx colorized" data-line="264" data-line-first="265" style="display:block"><code data-line="265">  <span style="color:blue">class</span> LL&lt;T&gt; ... {

    <span style="color:blue">function</span> Head(): T {
      value
    }

    <span style="color:blue">function</span> Tail(): LL&lt;T&gt;
      <span style="color:purple">requires</span> next != <span style="color:blue">null</span>
      <span style="color:purple">reads</span> <span style="color:blue">this</span>
    {
      next
    }

  }</code></pre></li></ul>
</section>
<section id="sec-linked-list-example----4" class="section section1" data-section-depth="1" data-line="281"><h2 id="heading-sec-linked-list-example----4" class="h1" data-heading-depth="1" style="display:block">Linked list example &#8211; 4</h2>
<ul class="ul list-dash loose" data-line="283">
<li class="li ul-li list-dash-li loose-li" data-line="283">
<p data-line="283"><span data-line="283"></span><code class="code code1">Length</code><span data-line="283"></span> is problematic
</p></li>
<li class="li ul-li list-dash-li loose-li" data-line="284">
<p data-line="284"><span data-line="284"></span>We need to ensure that the function terminates
</p></li>
<li class="li ul-li list-dash-li loose-li" data-line="285">
<p data-line="285"><span data-line="285"></span>Intuitively we know why it does:
</p></li>
<li class="li ul-li list-dash-li loose-li" data-line="286">
<p data-line="286"><span data-line="286"></span>We <span data-line="286"></span><em class="em-star1">intend</em><span data-line="286"></span> for the <span data-line="286"></span><code class="code code1">LL</code><span data-line="286"></span> not to be cyclic
</p></li>
<li class="li ul-li list-dash-li loose-li" data-line="287">
<p data-line="287"><span data-line="287"></span>We will need to explicitate our intentions in the invariant
</p><!-- inline-dafny MutableDynamicDataStructures/A5 -->


<pre class="para-block pre-fenced pre-fenced3 language-dafnyx lang-dafnyx dafnyx colorized" data-line="290" data-line-first="291" style="display:block"><code data-line="291">  <span style="color:blue">class</span> LL&lt;T&gt; ... {

    <span style="color:blue">function</span> Length(): <span style="color:teal">nat</span>
      <span style="color:purple">reads</span> <span style="color:blue">this</span>
    {
      <span class="constant" style="color:purple">1</span> + <span style="color:blue">if</span> next == <span style="color:blue">null</span> <span style="color:blue">then</span> <span class="constant" style="color:purple">0</span> <span style="color:blue">else</span> next.Length() <span style="color:darkgreen">// Error: might not terminate</span>
    }

  }</code></pre></li></ul>
</section>
<section id="sec-dynamic-frames" class="section section1" data-section-depth="1" data-line="302"><h2 id="heading-sec-dynamic-frames" class="h1" data-heading-depth="1" style="display:block">Dynamic frames</h2>
<ul class="ul list-dash loose" data-line="304">
<li class="li ul-li list-dash-li loose-li" data-line="304">
<p data-line="304"><span data-line="304"></span>We need to reason about the set of objects composing the <span data-line="304"></span><code class="code code1">LL</code><span data-line="304"></span>
</p></li>
<li class="li ul-li list-dash-li loose-li" data-line="305">
<p data-line="305"><span data-line="305"></span>We can use a ghost set <span data-line="305"></span><em class="em-low1">dynamic frame</em><span data-line="305"></span>
</p></li>
<li class="li ul-li list-dash-li loose-li" data-line="306">
<p data-line="306"><span data-line="306"></span>We can state that a cell is not in the representation of its successor
</p></li>
<li class="li ul-li list-dash-li loose-li" data-line="307">
<p data-line="307"><span data-line="307"></span>This implies the list cannot be cyclic
</p><!-- inline-dafny MutableDynamicDataStructures/A6 -->


<pre class="para-block pre-fenced pre-fenced3 language-dafnyx lang-dafnyx dafnyx colorized" data-line="310" data-line-first="311" style="display:block"><code data-line="311">  <span style="color:blue">class</span> LL&lt;T&gt; ... {

    <span style="color:blue">ghost</span> <span style="color:blue">var</span> Repr: <span style="color:teal">set</span>&lt;<span style="color:teal">object</span>&gt;

    <span style="color:blue">ghost</span> <span style="color:blue">predicate</span> Invariant()
      <span style="color:purple">reads</span> <span style="color:blue">this</span>, Repr
      <span style="color:purple">decreases</span> Repr
    {
      &amp;&amp; <span style="color:blue">this</span> <span style="color:blue">in</span> Repr
      &amp;&amp; (next != <span style="color:blue">null</span> ==&gt;
         &amp;&amp; next <span style="color:blue">in</span> Repr
         &amp;&amp; next.Repr &lt;= Repr
         &amp;&amp; <span style="color:blue">this</span> !<span style="color:blue">in</span> next.Repr
         &amp;&amp; next.Invariant())
    }

  }</code></pre></li></ul>
</section>
<section id="sec-go-over-existing-code-again----1" class="section section1" data-section-depth="1" data-line="330"><h2 id="heading-sec-go-over-existing-code-again----1" class="h1" data-heading-depth="1" style="display:block">Go over existing code again &#8211; 1</h2>
<ul class="ul list-dash loose" data-line="332">
<li class="li ul-li list-dash-li loose-li" data-line="332">
<p data-line="332"><span data-line="332"></span>We strengthened the invariant
</p></li>
<li class="li ul-li list-dash-li loose-li" data-line="333">
<p data-line="333"><span data-line="333"></span>We need to review all the methods for which it is a postcondition
</p><!-- inline-dafny MutableDynamicDataStructures/A7 -->


<pre class="para-block pre-fenced pre-fenced3 language-dafnyx lang-dafnyx dafnyx colorized" data-line="336" data-line-first="337" style="display:block"><code data-line="337">  <span style="color:blue">class</span> LL&lt;T&gt; ... {

    <span style="color:blue">constructor</span> OH(value: T)
      <span style="color:purple">ensures</span> <span style="color:blue">this</span>.value == value
      <span style="color:purple">ensures</span> <span style="color:blue">this</span>.next == <span style="color:blue">null</span>
      <span style="color:purple">ensures</span> Invariant()
    {
      <span style="color:blue">this</span>.value := value;
      next := <span style="color:blue">null</span>;
      Repr := {<span style="color:blue">this</span>};
    }

  }</code></pre></li></ul>
</section>
<section id="sec-go-over-existing-code-again----2" class="section section1" data-section-depth="1" data-line="352"><h2 id="heading-sec-go-over-existing-code-again----2" class="h1" data-heading-depth="1" style="display:block">Go over existing code again &#8211; 2</h2>
<ul class="ul list-dash loose" data-line="354">
<li class="li ul-li list-dash-li loose-li" data-line="354">
<p data-line="354"><span data-line="354"></span>This is a good strategy to develop verified data structures
</p></li>
<li class="li ul-li list-dash-li loose-li" data-line="355">
<p data-line="355"><span data-line="355"></span>Add methods one by one, strengthening invariant as you go, adapting existing code every time
</p><!-- inline-dafny MutableDynamicDataStructures/A8 -->


<pre class="para-block pre-fenced pre-fenced3 language-dafnyx lang-dafnyx dafnyx colorized" data-line="358" data-line-first="359" style="display:block"><code data-line="359">  <span style="color:blue">class</span> LL&lt;T&gt; ... {

    <span style="color:blue">method</span> Cons(v: T) <span style="color:blue">returns</span> (l: LL&lt;T&gt;)
      <span style="color:purple">requires</span> Invariant()
      <span style="color:purple">modifies</span> Repr
      <span style="color:purple">ensures</span> Invariant()
      <span style="color:purple">ensures</span> l.Invariant()
    {
      l := <span style="color:blue">new</span> LL(v);
      l.next := <span style="color:blue">this</span>;
      l.Repr := Repr + {l};
    }

  }</code></pre></li></ul>
</section>
<section id="sec-length" class="section section1" data-section-depth="1" data-line="375"><h2 id="heading-sec-length" class="h1" data-heading-depth="1" style="display:block">Length</h2>
<ul class="ul list-dash loose" data-line="377">
<li class="li ul-li list-dash-li loose-li" data-line="377">
<p data-line="377"><span data-line="377"></span>Now the invariant is strong enough for <span data-line="377"></span><code class="code code1">Length</code><span data-line="377"></span>
</p></li>
<li class="li ul-li list-dash-li loose-li" data-line="378">
<p data-line="378"><span data-line="378"></span>In practice, there is a continuous co-design of invariant and code
</p><!-- inline-dafny MutableDynamicDataStructures/A9 -->


<pre class="para-block pre-fenced pre-fenced3 language-dafnyx lang-dafnyx dafnyx colorized" data-line="381" data-line-first="382" style="display:block"><code data-line="382">  <span style="color:blue">class</span> LL&lt;T&gt; ... {

    <span style="color:blue">function</span> Length(): <span style="color:teal">nat</span>
      <span style="color:purple">requires</span> Invariant()
      <span style="color:purple">reads</span> Repr
      <span style="color:purple">decreases</span> Repr
    {
      <span class="constant" style="color:purple">1</span> + <span style="color:blue">if</span> next == <span style="color:blue">null</span> <span style="color:blue">then</span> <span class="constant" style="color:purple">0</span> <span style="color:blue">else</span> next.Length()
    }

  }</code></pre></li></ul>
</section>
<section id="sec-append----1" class="section section1" data-section-depth="1" data-line="395"><h2 id="heading-sec-append----1" class="h1" data-heading-depth="1" style="display:block">Append &#8211; 1</h2>
<ul class="ul list-dash loose" data-line="397">
<li class="li ul-li list-dash-li loose-li" data-line="397">
<p data-line="397"><span data-line="397"></span>Append is interesting because it involves two LLs
</p></li>
<li class="li ul-li list-dash-li loose-li" data-line="398">
<p data-line="398"><span data-line="398"></span>We need to require the LLs to be made of distinct objects
</p><!-- inline-dafny MutableDynamicDataStructures/A10 -->


<pre class="para-block pre-fenced pre-fenced3 language-dafnyx lang-dafnyx dafnyx colorized" data-line="401" data-line-first="402" style="display:block"><code data-line="402">  <span style="color:blue">class</span> LL&lt;T&gt; ... {

    <span style="color:blue">method</span> Append(l: LL&lt;T&gt;)
      <span style="color:purple">requires</span> next != <span style="color:blue">null</span>
      <span style="color:purple">requires</span> Invariant()
      <span style="color:purple">requires</span> l.Invariant()
      <span style="color:purple">modifies</span> Repr
      <span style="color:purple">ensures</span> Invariant()

  }</code></pre></li></ul>
</section>
<section id="sec-append----2" class="section section1" data-section-depth="1" data-line="414"><h2 id="heading-sec-append----2" class="h1" data-heading-depth="1" style="display:block">Append &#8211; 2</h2>
<ul class="ul list-dash loose" data-line="416">
<li class="li ul-li list-dash-li loose-li" data-line="416">
<p data-line="416"><span data-line="416"></span>We do so with the <span data-line="416"></span><em class="em-star1">frame rule</em><span data-line="416"></span> 
</p></li>
<li class="li ul-li list-dash-li loose-li" data-line="417">
<p data-line="417"><span data-line="417"></span>Here, <span data-line="417"></span><code class="code code1">Append</code><span data-line="417"></span> requires some proof work
</p><!-- inline-dafny MutableDynamicDataStructures/A11 -->


<pre class="para-block pre-fenced pre-fenced3 language-dafnyx lang-dafnyx dafnyx colorized" data-line="420" data-line-first="421" style="display:block"><code data-line="421">  <span style="color:blue">class</span> LL&lt;T&gt; ... {

    <span style="color:blue">method</span> Append(l: LL&lt;T&gt;)
      <span style="color:purple">requires</span> next == <span style="color:blue">null</span>
      <span style="color:purple">requires</span> Invariant()
      <span style="color:purple">requires</span> Repr !! l.Repr
      <span style="color:purple">requires</span> l.Invariant()
      <span style="color:purple">modifies</span> Repr
      <span style="color:purple">ensures</span> Invariant() <span style="color:darkgreen">// Fails</span>
    {
      next := l;
      Repr := Repr + l.Repr;
    }

  }</code></pre></li></ul>
</section>
<section id="sec-proof-methodology" class="section section1" data-section-depth="1" data-line="438"><h2 id="heading-sec-proof-methodology" class="h1" data-heading-depth="1" style="display:block">Proof methodology</h2>
<ul class="ul list-dash compact" data-line="440">
<li class="li ul-li list-dash-li compact-li" data-line="440"><span data-line="440"></span>Use the forward/backward approach to meet in the middle and identify the issue
</li>
<li class="li ul-li list-dash-li compact-li" data-line="441"><span data-line="441"></span>It could be one of 3 things: invariant too weak, code wrong, proof not detailed enough
</li>
<li class="li ul-li list-dash-li compact-li" data-line="442"><span data-line="442"></span>Proofs help you diagnose the source of the problem, in this case: Dafny!
</li>
<li class="li ul-li list-dash-li compact-li" data-line="443"><span data-line="443"></span>Meeting in the middle: <span data-line="443"></span><code class="code code1">forall c: LL :: c in old(Repr) ==&gt; c !in l.Repr</code><span data-line="443"></span>
</li>
<li class="li ul-li list-dash-li compact-li" data-line="444"><span data-line="444"></span>Dafny needs some help with the following lemma
</li></ul>
</section>
<section id="sec-linked-list-example----5" class="section section1" data-section-depth="1" data-line="447"><h2 id="heading-sec-linked-list-example----5" class="h1" data-heading-depth="1" style="display:block">Linked list example &#8211; 5</h2>
<ul class="ul list-dash loose" data-line="449">
<li class="li ul-li list-dash-li loose-li" data-line="449">
<p data-line="449"><span data-line="449"></span>The previous example is a common way to verify linked list
</p></li>
<li class="li ul-li list-dash-li loose-li" data-line="450">
<p data-line="450"><span data-line="450"></span>In Dafny, you can do much much better
</p></li>
<li class="li ul-li list-dash-li loose-li" data-line="451">
<p data-line="451"><span data-line="451"></span>Let<span data-line="451"></span>&#39;<span data-line="451"></span>s use dummy cells and a special root
</p><!-- inline-dafny MutableDynamicDataStructures/A12 -->


<pre class="para-block pre-fenced pre-fenced3 language-dafnyx lang-dafnyx dafnyx colorized" data-line="454" data-line-first="455" style="display:block"><code data-line="455">  <span style="color:blue">class</span> Cell&lt;T&gt; {

    <span style="color:blue">var</span> next: Cell?&lt;T&gt;
    <span style="color:blue">var</span> value: T

    <span style="color:blue">constructor</span>(value: T)
      <span style="color:purple">ensures</span> <span style="color:blue">this</span>.value == value
      <span style="color:purple">ensures</span> <span style="color:blue">this</span>.next == <span style="color:blue">null</span>
    {
      <span style="color:blue">this</span>.value := value;
      next := <span style="color:blue">null</span>;
    }

  }</code></pre></li></ul>
</section>
<section id="sec-roots-to-the-rescue" class="section section1" data-section-depth="1" data-line="471"><h2 id="heading-sec-roots-to-the-rescue" class="h1" data-heading-depth="1" style="display:block">Roots to the rescue</h2>
<ul class="ul list-dash loose" data-line="473">
<li class="li ul-li list-dash-li loose-li" data-line="473">
<p data-line="473"><span data-line="473"></span>The LL will be defined as its root, as opposed to a cell
</p></li>
<li class="li ul-li list-dash-li loose-li" data-line="474">
<p data-line="474"><span data-line="474"></span>Here, Dafny shines: you can use any existing ghost data structure
</p></li>
<li class="li ul-li list-dash-li loose-li" data-line="475">
<p data-line="475"><span data-line="475"></span>Intuitively, we think of an LL as a sequence of cells
</p></li>
<li class="li ul-li list-dash-li loose-li" data-line="476">
<p data-line="476"><span data-line="476"></span>We can capture this directly in the representation!
</p></li>
<li class="li ul-li list-dash-li loose-li" data-line="477">
<p data-line="477"><span data-line="477"></span>Hence, we declare the <span data-line="477"></span><em class="em-star1">representation</em><span data-line="477"></span> to be a sequence
</p><!-- inline-dafny MutableDynamicDataStructures/A13 -->


<pre class="para-block pre-fenced pre-fenced3 language-dafnyx lang-dafnyx dafnyx colorized" data-line="480" data-line-first="481" style="display:block"><code data-line="481">  <span style="color:blue">class</span> LL&lt;T&gt; {

    <span style="color:blue">var</span> length: <span style="color:teal">nat</span>
    <span style="color:blue">ghost</span> <span style="color:blue">var</span> Repr: <span style="color:teal">seq</span>&lt;Cell&lt;T&gt;&gt;
    <span style="color:blue">var</span> hd: Cell?&lt;T&gt;

  }</code></pre></li></ul>
</section>
<section id="sec-thinking-ahead-of-the-invariant" class="section section1" data-section-depth="1" data-line="490"><h2 id="heading-sec-thinking-ahead-of-the-invariant" class="h1" data-heading-depth="1" style="display:block">Thinking ahead of the invariant</h2>
<ul class="ul list-dash loose" data-line="492">
<li class="li ul-li list-dash-li loose-li" data-line="492">
<p data-line="492"><span data-line="492"></span>Again, we could grow the invariant
</p></li>
<li class="li ul-li list-dash-li loose-li" data-line="493">
<p data-line="493"><span data-line="493"></span>But with the additional structured dynamic frames, it is easier to capture our intuition
</p><!-- inline-dafny MutableDynamicDataStructures/A14 -->


<pre class="para-block pre-fenced pre-fenced3 language-dafnyx lang-dafnyx dafnyx colorized" data-line="496" data-line-first="497" style="display:block"><code data-line="497">  <span style="color:blue">class</span> LL&lt;T&gt; ... {

    <span style="color:blue">ghost</span> <span style="color:blue">predicate</span> Invariant()
      <span style="color:purple">reads</span> <span style="color:blue">this</span>, Repr
    {
      &amp;&amp; length == |Repr|
      &amp;&amp; (length == <span class="constant" style="color:purple">0</span> &lt;==&gt; hd == <span style="color:blue">null</span>)
      &amp;&amp; (length &gt; <span class="constant" style="color:purple">0</span> ==&gt; Repr[<span class="constant" style="color:purple">0</span>] == hd)
      &amp;&amp; (length &gt; <span class="constant" style="color:purple">0</span> ==&gt; Repr[length-<span class="constant" style="color:purple">1</span>].next == <span style="color:blue">null</span>)
      &amp;&amp; (<span style="color:blue">forall</span> idx: <span style="color:teal">nat</span> :: idx &lt; length - <span class="constant" style="color:purple">1</span> ==&gt;
          Repr[idx].next != <span style="color:blue">null</span>
          &amp;&amp; Repr[idx].next == Repr[idx+<span class="constant" style="color:purple">1</span>]
         )
    }

  }</code></pre></li></ul>
</section>
<section id="sec-linked-list-example----6" class="section section1" data-section-depth="1" data-line="515"><h2 id="heading-sec-linked-list-example----6" class="h1" data-heading-depth="1" style="display:block">Linked list example &#8211; 6</h2>
<ul class="ul list-dash loose" data-line="517">
<li class="li ul-li list-dash-li loose-li" data-line="517">
<p data-line="517"><span data-line="517"></span>Nothing surprising, just need to initialize the dynamic frame
</p><!-- inline-dafny MutableDynamicDataStructures/A15 -->


<pre class="para-block pre-fenced pre-fenced3 language-dafnyx lang-dafnyx dafnyx colorized" data-line="520" data-line-first="521" style="display:block"><code data-line="521">  <span style="color:blue">class</span> LL&lt;T&gt; ... {

    <span style="color:blue">constructor</span>()
      <span style="color:purple">ensures</span> hd == <span style="color:blue">null</span>
      <span style="color:purple">ensures</span> length == <span class="constant" style="color:purple">0</span>
      <span style="color:purple">ensures</span> Invariant()
    {
      length := <span class="constant" style="color:purple">0</span>;
      hd := <span style="color:blue">null</span>;
      Repr := [];
    }

  }</code></pre></li></ul>
</section>
<section id="sec-linked-list-example----7" class="section section1" data-section-depth="1" data-line="536"><h2 id="heading-sec-linked-list-example----7" class="h1" data-heading-depth="1" style="display:block">Linked list example &#8211; 7</h2>
<ul class="ul list-dash compact" data-line="538">
<li class="li ul-li list-dash-li compact-li" data-line="538"><span data-line="538"></span>Implement methods one by one
</li></ul>
<!-- inline-dafny MutableDynamicDataStructures/A16 -->


<pre class="para-block pre-fenced pre-fenced3 language-dafnyx lang-dafnyx dafnyx colorized" data-line="541" data-line-first="542" style="display:block"><code data-line="542">  <span style="color:blue">class</span> LL&lt;T&gt; ... {

    <span style="color:blue">method</span> Cons(v: T)
      <span style="color:purple">requires</span> Invariant()
      <span style="color:purple">modifies</span> <span style="color:blue">this</span>, Repr
      <span style="color:purple">ensures</span> Invariant()
    {
      <span style="color:blue">var</span> o: Cell := <span style="color:blue">new</span> Cell(v);
      o.next := hd;
      hd := o;
      Repr := [o] + Repr;
      length := length + <span class="constant" style="color:purple">1</span>;
    }

  }</code></pre></section>
<section id="sec-linked-list-example----8" class="section section1" data-section-depth="1" data-line="559"><h2 id="heading-sec-linked-list-example----8" class="h1" data-heading-depth="1" style="display:block">Linked list example &#8211; 8</h2>
<ul class="ul list-dash compact" data-line="561">
<li class="li ul-li list-dash-li compact-li" data-line="561"><span data-line="561"></span>The anti-aliasing is surprisingly easier to state
</li></ul>
<!-- inline-dafny MutableDynamicDataStructures/A17 -->


<pre class="para-block pre-fenced pre-fenced3 language-dafnyx lang-dafnyx dafnyx colorized" data-line="564" data-line-first="565" style="display:block"><code data-line="565">  <span style="color:blue">class</span> LL&lt;T&gt; ... {

    <span style="color:blue">method</span> AppendNull(l: LL&lt;T&gt;)
      <span style="color:purple">requires</span> length == <span class="constant" style="color:purple">1</span>
      <span style="color:purple">requires</span> Invariant()
      <span style="color:purple">requires</span> l.Invariant()
      <span style="color:purple">requires</span> Repr[<span class="constant" style="color:purple">0</span>] !<span style="color:blue">in</span> l.Repr
      <span style="color:purple">modifies</span> <span style="color:blue">this</span>, Repr
      <span style="color:purple">ensures</span> Invariant()
    {
      <span style="color:blue">if</span> l.length == <span class="constant" style="color:purple">0</span> {
      } <span style="color:blue">else</span> {
        hd.next := l.hd;
        Repr := Repr + l.Repr;
        length := length + l.length;
      }
    }

  }</code></pre></section></div></div><span data-line=""></span></div>
</body>
<script type="text/javascript">
  Reveal.initialize({
          history: true,
          transition: "none",
          width: 1600,
            height: 900,
          center: false,
          controls: false,
             progress: false,
          slideNumber: true
          });
  Reveal.configure({
          history: true,
          transition: "none",
          width: 1600,
            height: 900,
          center: false,
          controls: false,
             progress: false,
          slideNumber: true
     });
</script>
<script>
    // initialize printing
    revealConfig.initPrint();
    // initialize background embedded images
    revealConfig.getEmbeddedImages();
    </script>
</html>
